[{"content":"有好多版本，好有意思\ngit 你怎么能直接 commit 到我的 main 分支啊？！GitHub 上不是这样！你应该先 fork 我的仓库，然后从 develop 分支 checkout 一个新的 feature 分支，比如叫 feature/confession。然后你把你的心意写成代码，并为它写好单元测试和集成测试，确保代码覆盖率达到95%以上。接着你要跑一下 Linter，通过所有的代码风格检查。然后你再 commit，commit message 要遵循 Conventional Commits 规范。之后你把这个分支 push 到你自己的远程仓库，然后给我提一个 Pull Request。在 PR 描述里，你要详细说明你的功能改动和实现思路，并且 @ 我和至少两个其他的评审。我们会 review 你的代码，可能会留下一些评论，你需要解决所有的 thread。等 CI/CD 流水线全部通过，并且拿到至少两个 LGTM 之后，我才会考虑把你的分支 squash and merge 到 develop 里，等待下一个版本发布。你怎么直接上来就想 force push 到 main？！GitHub 上根本不是这样！我拒绝合并！\nRAG系统 你怎么能直接 client.chat.completions.create 去调大模型啊？！企业级 RAG 系统里不是这样！你应该先通过 ETL 流水线把 PDF 和 PPT 清洗一遍，跑一遍 OCR 和 Layout Analysis 提取图片里的图表信息。接着你要用 Recursive Character Text Splitter 按照语义完整性做 Chunking，并调用 CLIP 或者 BGE-M3 模型生成多模态 Embeddings。然后你要把这些高维向量存进 Milvus 或者 Weaviate，构建好 HNSW 索引。接着用户提问的时候，你要先做 Query Rewriting，生成多路查询，去走一遍 Hybrid Search，同时结合 BM25 关键词和 Dense Vector 召回 Top-K 文档。然后你要过一遍 Cross-Encoder 的 Reranker 模型，把 Relevancy Score 低的脏数据过滤掉。之后你把这些图文切片按照 Token Limit 精心塞进 Prompt Template 的 Context Window 里，并严格要求模型基于引用回答。在生成 Response 之前，你要跑一遍 Guardrails 甚至用 RAGAS 框架做一轮评估，检查有没有幻觉，确保 Faithfulness 和 Answer Relevance 分数达标。等 Grounding Check 全部通过，并且没有触发 Sensitive Word Filter 之后，我才会考虑把 token 一个个 stream 推回给前端，等待用户反馈。你怎么直接上来就想裸调 API 靠模型瞎编？！知识库增强根本不是这样！我拒绝生成！\njava业务开发 你咋能直接用野指针访问我的数据？！😨 计算机体系结构、操作系统、数据结构、程序设计、面向对象都不是这样写的！😡 你得先通过我的静态方法 getInstance() 获取这个单例的引用！☝️ 接着，你必须调用 acquireToken() 方法，拿着你的 credential 到我的 AuthCenter 去换一个限时的 AccessToken！然后带着 Token 和你的请求参数，调用我接口里的 submitRequest() 方法！😮 我的 RequestDispatcher 会把你丢过来的请求包装成一个 Runnable Task，直接扔进背后的 ThreadPoolExecutor！☺️ 线程池会从核心线程开始分配，如果满了就进队列，队列爆了才开临时线程，严格按照拒绝策略来！😤 等线程有空了，捞起你的 Task 一运行，这才真正走到我的业务实现类里！进来先得通过 @PreAuthorize 注解再鉴权一次，看看你的角色在不在 ACL 列表里！接着 @Transactional 注解会自动开启数据库事务，我的 DataMapper 才会用 PreparedStatement 去查数据库！🧐 查出来的 Entity 对象，还得经过一层 DTO 转换，把不该给你的字段统统剥掉！最后，这个干净的 DTO 才会被 Jackson 序列化成 JSON，由 Spring MVC 的 MessageConverter 通过 HTTP Response 还给你！☺️ 整个链路，任何一步不对，都有对应的 Exception 等着你——没权限抛 AccessDeniedException，参数错抛 IllegalArgumentException，查无此人抛 NotFoundException！全局异常处理器早等着了，直接给你转成带错误码的 JSON 体，顺便 @Async 记一条审计日志到数据库！😡 你居然还想绕过我这一整套面向对象封装和 Spring 生态，直接 (int)0x12345678 解引用？Java 的封装、多态、抽象呢？！你根本不懂什么叫业务逻辑！更不懂什么叫对象！😡\n数据库 你咋能直接在生产环境改数据库表结构？！😱 数据库设计、事务隔离、ACID原则、版本控制、DevOps流程都不是这么玩的！😡 你得先在 Jira 上提个变更单！☝️ 关联需求 ID 走评审流程，产品、测试、DBA 三方审批通过才算数！接着必须在本地环境搭镜像库，用 Flyway 写好 V 版迁移脚本，跑通单元测试和集成测试！😮 测试环境得先执行脚本做灰度验证！☺️ 观察 24 小时无数据异常，再同步到预发环境做压测，QPS 达标、响应时间稳定、没有锁等待才算过！😤 等所有环境验证完毕，才能在发布窗口执行生产变更！进来先得通过数据库审计系统校验，看看你的脚本有没有违反禁用语法！接着开启只读事务做预检查，我的 DBA 工具才会用批量执行模式提交 SQL！🧐 执行完必须跑数据校验脚本，对比前后字段完整性、索引有效性、关联表一致性！最后生成变更报告，同步到知识库归档，由监控系统盯紧后续 72 小时的慢查询和异常日志！☺️ 整个流程，任何一步跳票都有对应的告警等着你——没审批抛 UnauthorizedChangeException，脚本有误抛 SqlSyntaxException，数据不一致抛 DataMismatchException！运维平台早盯着了，直接触发工单通知责任人，顺便记录操作轨迹到审计链！😡 你居然还想跳过流程直接 Navicat 手动改字段？数据库的隔离、原子性、一致性呢？！你根本不懂什么叫变更管控！更不懂什么叫生产规范！😡\nOI 比赛 你怎么能直接把没调过的代码往洛谷一丢就想拿 AC 啊？！OI 比赛根本不是这样！ 你应该先老老实实在本地 freopen(\u0026ldquo;1.in\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); 把样例调三遍，然后把题面那堆坑读到能背下来，再对着数据范围判断是不是要开 long long、是不是要开 1e7 的数组会不会 MLE。 然后你应该先在本地写一个暴力对拍程序，准备好随机数据生成器 data.py，让正解和暴力对拍至少五分钟；期间你要注意 RE 是不是因为你数组开小了、是不是 vector.resize 写错了、是不是访问了奇怪的下标。 你还要记得在本地加 -O2 -std=c++14 -Wall，跑一遍 valgrind，确保你没有越界访问、没有野指针、没有未初始化变量。 写完之后，你要把你的正解在 /tmp 里跑一遍带 I/O 压力的极限数据，确认你的快读和快写都不会卡死；然后再把代码格式跑一下 clang-format，确保你不会被我这种评测机嫌弃代码太丑。 等你做完这些，你才可以把代码提交到洛谷。提交之前 commit message 要写： feat: solve P3384 using heavy-light decomposition and segment tree 提交上去之后如果评测机给你 WA，你应该点开“对比”看看是不是你少判了特判、是不是边界没处理、是不是初始化忘清零。 如果评测机给你 TLE，你要自己反省是不是用了 cin \u0026raquo;，是不是 vector 反复 push_back，还是用了 O(n²) 的假 DP。 如果评测机给你 MLE，你要想清楚是不是你堆上 malloc 太多、是不是你开了 10 个 1e7 的数组、是不是用了 STL 导致常数爆炸。 等你把所有 WA thread 和 TLE thread 都解决，终于从评测机那拿到一个干干净净的 绿色 Accepted √ 之后，我才会把你放进通过列表。 你怎么直接把你那个根本没跑对拍、没开 O2、甚至读入都写错的代码往我洛谷扔啊？！OI根本不是这样！ 我拒绝给你 AC！！！\n《计算机编年史》 你为啥一上来就让我写Python啊？！《计算机编年史》里不是这样！你应该先从机器语言开始，用手拨开关把二进制码输进内存，等指示灯闪烁出「Hello World」再开始练穿孔纸带。然后用汇编语言写移位指令，用AL寄存器做加法，在INT 21h里找DOS中断。等能在DEBUG里单步追踪寄存器了，才能开始学C语言，先配好Turbo C编译器，在main()里声明指针变量，用malloc申请堆内存，最后记得写free防止泄漏。等指针和结构体都玩透了，再去搞C++的类继承，写虚函数表，在构造函数里初始化成员列表，用模板元编程实现编译期计算。这些都通关了才轮到Python，在__init__里写self，用装饰器包装函数，拿列表推导式替代循环。最后才是Java——配好JVM环境，写public static void main，用Spring框架注入依赖，在DAO层建实体类映射数据库！你怎么直接打开IDLE就敲import？！《计算机编年史》里根本不是这样！我拒绝运行！！！\n","permalink":"http://localhost:1313/posts/%E4%B8%AA%E4%BA%BA-%E4%BD%A0%E6%80%8E%E4%B9%88%E8%83%BD%E7%9B%B4%E6%8E%A5.../","summary":"\u003cp\u003e有好多版本，好有意思\u003c/p\u003e\n\u003ch2 id=\"git\"\u003egit\u003c/h2\u003e\n\u003cp\u003e你怎么能直接 commit 到我的 main 分支啊？！GitHub 上不是这样！你应该先 fork 我的仓库，然后从 develop 分支 checkout 一个新的 feature 分支，比如叫 feature/confession。然后你把你的心意写成代码，并为它写好单元测试和集成测试，确保代码覆盖率达到95%以上。接着你要跑一下 Linter，通过所有的代码风格检查。然后你再 commit，commit message 要遵循 Conventional Commits 规范。之后你把这个分支 push 到你自己的远程仓库，然后给我提一个 Pull Request。在 PR 描述里，你要详细说明你的功能改动和实现思路，并且 @ 我和至少两个其他的评审。我们会 review 你的代码，可能会留下一些评论，你需要解决所有的 thread。等 CI/CD 流水线全部通过，并且拿到至少两个 LGTM 之后，我才会考虑把你的分支 squash and merge 到 develop 里，等待下一个版本发布。你怎么直接上来就想 force push 到 main？！GitHub 上根本不是这样！我拒绝合并！\u003c/p\u003e\n\u003ch2 id=\"rag系统\"\u003eRAG系统\u003c/h2\u003e\n\u003cp\u003e你怎么能直接 client.chat.completions.create 去调大模型啊？！企业级 RAG 系统里不是这样！你应该先通过 ETL 流水线把 PDF 和 PPT 清洗一遍，跑一遍 OCR 和 Layout Analysis 提取图片里的图表信息。接着你要用 Recursive Character Text Splitter 按照语义完整性做 Chunking，并调用 CLIP 或者 BGE-M3 模型生成多模态 Embeddings。然后你要把这些高维向量存进 Milvus 或者 Weaviate，构建好 HNSW 索引。接着用户提问的时候，你要先做 Query Rewriting，生成多路查询，去走一遍 Hybrid Search，同时结合 BM25 关键词和 Dense Vector 召回 Top-K 文档。然后你要过一遍 Cross-Encoder 的 Reranker 模型，把 Relevancy Score 低的脏数据过滤掉。之后你把这些图文切片按照 Token Limit 精心塞进 Prompt Template 的 Context Window 里，并严格要求模型基于引用回答。在生成 Response 之前，你要跑一遍 Guardrails 甚至用 RAGAS 框架做一轮评估，检查有没有幻觉，确保 Faithfulness 和 Answer Relevance 分数达标。等 Grounding Check 全部通过，并且没有触发 Sensitive Word Filter 之后，我才会考虑把 token 一个个 stream 推回给前端，等待用户反馈。你怎么直接上来就想裸调 API 靠模型瞎编？！知识库增强根本不是这样！我拒绝生成！\u003c/p\u003e","title":"「你怎么能直接...」"},{"content":"#最佳实践 一般来说不会有这个问题，老老实实进行“定义接口-\u0026gt;写实现类/匿名类-\u0026gt;new对象-\u0026gt;调用方法”自然会进行变量层面的抽象。 但lambda这种语法糖太简洁了，导致写的时候会忍不住追求更方便写法，导致jvm运行时的不方便\nList\u0026lt;String\u0026gt; strings = List.of(\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;, \u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;, \u0026#34;seven\u0026#34;); Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String word: strings) { int length = word.length(); map.merge(length, word, (existingValue, newWord) -\u0026gt; existingValue + \u0026#34;, \u0026#34; + newWord);//如果length不在map中，会绑定到word；如果存在，会用现有值和word调用双函数，双函数的结果替换当前值 } map.forEach((key, value) -\u0026gt; IO.println(key + \u0026#34; :: \u0026#34; + value)); 为什么这些lambda明明可以直接用外面的变量，如上面的newword，但还要把它作为一个参数传进来？ 可以让lambda变成“non-capturing”（不捕获外部变量），性能更好 对于non-capturing，JVM 可以把它当成纯函数对象、无状态对象来优化 可以实现成一个没有字段的单例对象，甚至整个程序里就用这一份；一次创建，到处复用。 不需要每次创建新对象； 更容易被 JIT 内联、优化。 如果进行捕获了，lambda 用到了外部的变量，编译器必须生成一个带字段的对象，里面存着 bonus 的值。在某些场景下，甚至每次使用都要 new 一份（或者至少要为每个不同捕获环境生成不同实例），分配成本更高，优化空间更小。 ","permalink":"http://localhost:1313/posts/code_trail-javaapi-from-dev-java-lambda%E5%86%99%E6%B3%95%E4%B8%8D%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8Fnon-capturing/","summary":"\u003cp\u003e#最佳实践\n一般来说不会有这个问题，老老实实进行“定义接口-\u0026gt;写实现类/匿名类-\u0026gt;new对象-\u0026gt;调用方法”自然会进行变量层面的抽象。\n但lambda这种语法糖太简洁了，导致写的时候会忍不住追求更方便写法，导致jvm运行时的不方便\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eList\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eString\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e strings \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e List.\u003cspan style=\"color:#a6e22e\"\u003eof\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;one\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;two\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;three\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;four\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;five\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;six\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;seven\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eMap\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eInteger, String\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e map \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e HashMap\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (String word: strings) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e length \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e word.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    map.\u003cspan style=\"color:#a6e22e\"\u003emerge\u003c/span\u003e(length, word, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              (existingValue, newWord) \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e existingValue \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;, \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e newWord);\u003cspan style=\"color:#75715e\"\u003e//如果length不在map中，会绑定到word；如果存在，会用现有值和word调用双函数，双函数的结果替换当前值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emap.\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e((key, value) \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e IO.\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e(key \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34; :: \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e value));\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col\u003e\n\u003cli\u003e为什么这些lambda明明可以直接用外面的变量，如上面的newword，但还要把它作为一个参数传进来？\n\u003cul\u003e\n\u003cli\u003e可以让lambda变成“non-capturing”（不捕获外部变量），性能更好\u003c/li\u003e\n\u003cli\u003e对于non-capturing，JVM 可以把它当成\u003cstrong\u003e纯函数对象、无状态对象\u003c/strong\u003e来优化\n\u003cul\u003e\n\u003cli\u003e可以实现成\u003cstrong\u003e一个没有字段的单例对象\u003c/strong\u003e，甚至整个程序里就用这一份；一次创建，到处复用。\u003c/li\u003e\n\u003cli\u003e不需要每次创建新对象；\u003c/li\u003e\n\u003cli\u003e更容易被 JIT 内联、优化。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e如果进行捕获了，lambda 用到了外部的变量，编译器必须生成一个\u003cstrong\u003e带字段的对象\u003c/strong\u003e，里面存着 bonus 的值。在某些场景下，甚至每次使用都要 new 一份（或者至少要为每个不同捕获环境生成不同实例），\u003cstrong\u003e分配成本更高，优化空间更小\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"lambda写法：不捕获外部变量（non-capturing）"},{"content":" 大伙自然地将entry和键值对联系在一起**“一个键值对就是一个 entry”**，于是java官方就把其作为造键值对的静态方法名 为什么会“自然地将entry和键值对联系在一起”？ entry 有“目录/词典里的一个条目”语义 map也很像词典/目录：词头、释义 ","permalink":"http://localhost:1313/posts/code_trail-javaapi-from-dev-java-map%E7%9A%84entry%E6%96%B9%E6%B3%95%E5%90%8D%E5%AD%97%E7%94%B1%E6%9D%A5%E5%8A%A9%E5%8A%9B%E8%AE%B0%E5%BF%86/","summary":"\u003col\u003e\n\u003cli\u003e大伙自然地将entry和键值对联系在一起**“一个键值对就是一个 entry”**，于是java官方就把其作为造键值对的静态方法名\u003c/li\u003e\n\u003cli\u003e为什么会“自然地将entry和键值对联系在一起”？\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eentry\u003c/em\u003e 有“目录/词典里的一个条目”语义\u003c/li\u003e\n\u003cli\u003e\u003cem\u003emap\u003c/em\u003e也很像词典/目录：词头、释义\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"Map的entry方法名字由来「助力记忆」"},{"content":"“长尾”指的是：主流需求之外，那条又长又细、数量巨大的“小需求带”\n除开很多人需求外，还有一部分“细长”区域，特点是 每个需求对应的人数不是那么多 需求种类很多 以前没人管这条尾巴，原因：软件开发成本高：人工成本、维护成本、需要“比较规范”才上线 现在：LLM、app生成工具、低成本部署使得面向特定小群体的app也值得一做。应用=内容，如15年前YouTube兴起一样 ","permalink":"http://localhost:1313/posts/other_record-%E9%95%BF%E5%B0%BE%E6%95%88%E5%BA%94%E6%A6%82%E5%BF%B5%E9%95%BF%E5%B0%BE%E5%BA%94%E7%94%A8%E4%B8%8E%E4%BB%8A%E5%A4%A9/","summary":"\u003cp\u003e“长尾”指的是：\u003cstrong\u003e主流需求之外，那条又长又细、数量巨大的“小需求带”\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e除开很多人需求外，还有一部分“细长”区域，特点是\n\u003cul\u003e\n\u003cli\u003e每个需求对应的人数不是那么多\u003c/li\u003e\n\u003cli\u003e需求种类很多\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e以前没人管这条尾巴，原因：软件开发成本高：人工成本、维护成本、需要“比较规范”才上线\u003c/li\u003e\n\u003cli\u003e现在：\u003cstrong\u003eLLM、app生成工具、低成本部署\u003c/strong\u003e使得面向特定小群体的app也值得一做。应用=内容，如15年前YouTube兴起一样\u003c/li\u003e\n\u003c/ul\u003e","title":"“长尾效应”概念「长尾应用」与今天"},{"content":"注：观点来自锦恢 注：内容来自该帖子评论区的回答 Q：训练岗应该能无缝转agent算法开发吧 A：只是把大模型接入应用，很简单，但是如果需要在特定任务上不微调模型的情况下把准确率提升到95%以上，就很难了。目前agent开发难点不在接入一个agent框架上，这件事没有任何技术难度，难在不断调整策略，在业务数据的迭代中设计出可以满足客户要求的准确率和可靠性的系统。后训练模型只是一种解决思路，但是考虑到成本和实际的性能，频繁使用这个方法和只使用这个方法都是不可靠的。事实上，大模型到最终落地之间有一道很大的鸿沟，这道鸿沟就是agent开发的发力空间。很多纯算法出身的人都认为只要大模型一训好，就能自动落地让客户满意，事实上，并非如此。\n","permalink":"http://localhost:1313/posts/other_record-%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84ai-agent/","summary":"\u003cp\u003e注：观点来自\u003ca href=\"https://www.zhihu.com/people/9fa2264946e6a0ed6d2473a72315e47d\"\u003e锦恢\u003c/a\u003e\n注：内容来自\u003ca href=\"https://www.zhihu.com/pin/1947313576361562163\"\u003e该帖子评论区的回答\u003c/a\u003e\nQ：训练岗应该能无缝转agent算法开发吧\nA：只是把大模型接入应用，很简单，但是如果需要在特定任务上不微调模型的情况下把准确率提升到95%以上，就很难了。目前agent开发难点不在接入一个agent框架上，这件事没有任何技术难度，难在不断调整策略，在业务数据的迭代中设计出可以满足客户要求的准确率和可靠性的系统。后训练模型只是一种解决思路，但是考虑到成本和实际的性能，频繁使用这个方法和只使用这个方法都是不可靠的。事实上，大模型到最终落地之间有一道很大的鸿沟，这道鸿沟就是agent开发的发力空间。很多纯算法出身的人都认为只要大模型一训好，就能自动落地让客户满意，事实上，并非如此。\u003c/p\u003e","title":"到底什么是真正的ai-agent？"},{"content":"背景 看dev.java，学集合框架时，原文写了iteration，翻译总翻成遍历，觉得奇怪\n结论 都可以。“iterate” 既可以表示 “迭代”，也可以表示 “遍历”\niterate演化出两层含义\n机械地重复执行（即迭代算法中“反复求近似解”那种含义）； 依次访问集合中的每个元素（即遍历集合）。 编程中\n“迭代器（iterator）” 是一种机制 “遍历（iteration）” 是这种机制实现的动作 参考 https://www.zhihu.com/question/39854900 ","permalink":"http://localhost:1313/posts/code_trail-javaapi-from-dev-java-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%81%8D%E5%8E%86%E7%BF%BB%E8%AF%91%E9%97%AE%E9%A2%98iteration/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e看\u003ccode\u003edev.java\u003c/code\u003e，学集合框架时，原文写了iteration，翻译总翻成遍历，觉得奇怪\u003c/p\u003e\n\u003ch2 id=\"结论\"\u003e结论\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e都可以。“iterate” 既可以表示 “迭代”，也可以表示 “遍历”\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eiterate演化出两层含义\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e机械地重复执行\u003c/strong\u003e（即迭代算法中“反复求近似解”那种含义）；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e依次访问集合中的每个元素\u003c/strong\u003e（即遍历集合）。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e编程中\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e“迭代器（iterator）” 是一种机制\u003c/li\u003e\n\u003cli\u003e“遍历（iteration）” 是这种机制实现的动作\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"参考\"\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://www.zhihu.com/question/39854900\"\u003ehttps://www.zhihu.com/question/39854900\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e","title":"迭代和遍历翻译问题iteration"},{"content":"很棒的资料 https://jamesakl.com/posts/cuda-ontology/ 详细系统讲解了CUDA整体 从顶往下：GPU 软件栈的层次结构 可以把 CUDA 系统理解成从硬件到应用的四层结构：\n┌──────────────────────────┐ │ 你的深度学习程序 (PyTorch / TensorFlow) │ ← 应用层 ├──────────────────────────┤ │ CUDA Toolkit / cuDNN / cuBLAS / 驱动API │ ← 开发与加速库层 ├──────────────────────────┤ │ NVIDIA 驱动 (Driver) │ ← 驱动层 ├──────────────────────────┤ │ GPU 硬件 (2080 Ti 等) │ ← 硬件层 └──────────────────────────┘ “我的 Python 程序通过 PyTorch 调用 CUDA Runtime API， CUDA Runtime 依赖 NVIDIA 驱动与硬件通信， 驱动再控制显卡完成底层计算。”\n“CUDA 生态是一整套 GPU 加速栈： 从最底层的硬件到驱动，再到 Toolkit 和加速库，最后被深度学习框架调用。 驱动连接硬件，Toolkit 提供编译和库接口， 框架调用这些接口完成并行计算。”\n层级 名称 作用 举例或说明 硬件层 GPU 芯片 负责并行计算（核心算力来源） RTX 2080 Ti, RTX 3070, A100 驱动层 NVIDIA Driver 操作系统和 GPU 之间的桥梁，负责调度 GPU 资源 比如 Driver Version: 535.230.02 运行库层 CUDA Runtime / cuDNN / cuBLAS / cuFFT 等 NVIDIA 提供的各种 GPU 加速库 PyTorch 调用 cuDNN 做卷积、cuBLAS 做矩阵乘 工具包层 CUDA Toolkit 包含编译器 nvcc、头文件、开发工具 CUDA 11.3, 12.1 等 应用层 深度学习框架 / 程序 你的 Python 代码、PyTorch、TensorFlow 等 torch.cuda.is_available() 驱动必须 ≥ CUDA Toolkit 要求的最低版本。驱动新版可以兼容老 CUDA。\n当用 conda install pytorch cudatoolkit=11.3 时，这套 CUDA runtime 是内置在 PyTorch 包里的，不会依赖系统路径\n所以哪怕系统没装 /usr/local/cuda，PyTorch 依然能跑。 torch.version.cuda 看到的版本即 PyTorch 编译时自带的 CUDA 版本。 排查命令\n检查命令 作用 nvidia-smi 驱动+GPU检测 nvcc -V CUDA Toolkit 版本（如果系统安装了） python -c \u0026ldquo;import torch; print(torch.version.cuda)\u0026rdquo; PyTorch 自带 CUDA 版本 torch.cuda.is_available() 是否能用 GPU ","permalink":"http://localhost:1313/posts/code_trail-cuda-%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90-%E9%9D%A2%E5%90%91%E4%BB%96%E4%BA%BA%E8%AE%B2%E8%A7%A3/","summary":"\u003ch2 id=\"很棒的资料\"\u003e很棒的资料\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://jamesakl.com/posts/cuda-ontology/\"\u003ehttps://jamesakl.com/posts/cuda-ontology/\u003c/a\u003e 详细系统讲解了CUDA整体\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"从顶往下gpu-软件栈的层次结构\"\u003e从顶往下：GPU 软件栈的层次结构\u003c/h2\u003e\n\u003cp\u003e可以把 CUDA 系统理解成\u003cstrong\u003e从硬件到应用的四层结构\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e┌──────────────────────────┐\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e│ 你的深度学习程序 \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003ePyTorch / TensorFlow\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e │ ← 应用层\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e├──────────────────────────┤\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e│ CUDA Toolkit / cuDNN / cuBLAS / 驱动API │ ← 开发与加速库层\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e├──────────────────────────┤\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e│ NVIDIA 驱动 \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003eDriver\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e │ ← 驱动层\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e├──────────────────────────┤\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e│ GPU 硬件 \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2080\u003c/span\u003e Ti 等\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e │ ← 硬件层\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e└──────────────────────────┘\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e“我的 Python 程序通过 PyTorch 调用 CUDA Runtime API，\u003c/strong\u003e\n\u003cstrong\u003eCUDA Runtime 依赖 NVIDIA 驱动与硬件通信，\u003c/strong\u003e\n\u003cstrong\u003e驱动再控制显卡完成底层计算。”\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e“CUDA 生态是一整套 GPU 加速栈：\u003c/strong\u003e\n\u003cstrong\u003e从最底层的硬件到驱动，再到 Toolkit 和加速库，最后被深度学习框架调用。\u003c/strong\u003e\n\u003cstrong\u003e驱动连接硬件，Toolkit 提供编译和库接口，\u003c/strong\u003e\n\u003cstrong\u003e框架调用这些接口完成并行计算。”\u003c/strong\u003e\u003c/p\u003e","title":"CUDA 的系统组成-面向他人讲解"},{"content":"泪水之城描述 如\n一座由繁华转为死寂的城市，总是下着雨 阴暗的小巷，总是潮湿多雨，高耸入云/不切实际的尖塔，幽深的地下城 风格? 搜索失败了，并没有准确的答案。\nreddit上确实有相关讨论，但是都是模糊模棱两可的\n感觉最像的是哥特式 城市：Prague\n如果天气是雨天就更好了。这种感觉绝了\n一位似乎是艺术领域或者爱好者？的回答 《空洞骑士》中的几种设计可能受到了历史悠久的维多利亚式建筑（更多例子）和第二帝国风格的启发，带有巴洛克和哥特式的影响和风格，并带有一丝新艺术风格。 是的，维多利亚式，高耸的尖塔，笔直的墙壁\n","permalink":"http://localhost:1313/posts/other_record-%E6%B3%AA%E6%B0%B4%E4%B9%8B%E5%9F%8E%E7%9A%84%E8%89%BA%E6%9C%AF%E9%A3%8E%E6%A0%BC/","summary":"\u003ch2 id=\"泪水之城描述\"\u003e泪水之城描述\u003c/h2\u003e\n\u003cp\u003e如\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e一座由繁华转为死寂的城市，总是下着雨\u003c/li\u003e\n\u003cli\u003e阴暗的小巷，总是潮湿多雨，高耸入云/不切实际的尖塔，幽深的地下城\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"风格\"\u003e风格?\u003c/h2\u003e\n\u003cp\u003e搜索失败了，并没有准确的答案。\u003c/p\u003e\n\u003cp\u003ereddit上确实有相关讨论，但是都是模糊模棱两可的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e感觉最像的是哥特式\n\u003c!-- raw HTML omitted --\u003e城市：Prague\u003c/p\u003e\n\u003cp\u003e如果天气是雨天就更好了。这种感觉绝了\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e一位似乎是艺术领域或者爱好者？的回答\n《空洞骑士》中的几种设计可能受到了历史悠久的维多利亚式建筑（更多例子）和第二帝国风格的启发，带有巴洛克和哥特式的影响和风格，并带有一丝新艺术风格。\n是的，维多利亚式，高耸的尖塔，笔直的墙壁\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"泪水之城的艺术风格"},{"content":"mac里的一款软件、包管理工具，提供快捷的依赖关系整理\n安装命令「使用官网脚本安装」：/bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot; 检查：brew --version 使用：brew install mysql 首次配置参考教程：https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/ 注意\n配置brew本身的镜像源「否则其自身的update将会很慢」 配置仓库的镜像源「否则其下载会很慢」 ","permalink":"http://localhost:1313/posts/code_trail-homebrew/","summary":"\u003cp\u003emac里的一款软件、包管理工具，提供快捷的依赖关系整理\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e安装命令「使用官网脚本安装」：\u003ccode\u003e/bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e检查：\u003ccode\u003ebrew --version\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e使用：\u003ccode\u003ebrew install mysql\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e首次配置参考教程：https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/\n注意\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e配置brew本身的镜像源「否则其自身的update将会很慢」\u003c/li\u003e\n\u003cli\u003e配置仓库的镜像源「否则其下载会很慢」\u003c/li\u003e\n\u003c/ol\u003e","title":"Homebrew"}]